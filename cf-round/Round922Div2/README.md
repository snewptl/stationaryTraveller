# 本场摘要

D 题没有涉及到什么前置知识，蛮适合作为某些笔试中的压轴题的，如果对滑动窗口类型的 DP 的了解变得生疏的话，这道题目还是有一定难度的。

E，F，G 难度相差不大，不过要在两小时内全部通过还是比较困难，自己做的时候wa了若干次——还是再接再厉吧。

**传送门：**

[题目](https://codeforces.com/contest/1918)

[博客中的题解（推荐）](http://snewptl.com/2024/02/20/Codeforces-Round922Div2/)

# C. 

**题目大意：**

输入三个数字 A，B，X。求如下式子：

$$
\operatorname{Min}\{|(A \oplus x)-(B \oplus x)|\}, 0 \leqslant x \leqslant X
$$

**题解：**

不妨设$A>B$, 且将 A 和 B 都用二进制表示。

由于 A 和 B 都要和 X 进行异或操作，如果某一个位上 A 和 B 都为 1 或者 0 ，那么将 x 的对应位置为 0 即可。这样一来，异或操作的作用，可以理解成将一个数字中某个位置上的 1，移动到另一个数字中的对应位置中去。

所以期望最小的方案就是，A 的最高的 1 不动，然后尽可能地通过异或 x 将 A 中低位的 1 移动到 B 中去。

> 如果需要移动 A 中的 最高位的 1，那说明 X 大到足以将 A 的低位 1 全移动到 B 中，而这已经是是理论最优解了。所以没必要移动 A 的最高位 1。 

# D. 


小清新DP，想了一中午没想出来。。。看了题解豁然开朗，十分具有练习价值

（本题目的代码的文件名字为“starD.cpp”，值得特别关注的题目都会这样命名）

**题目大意：**

给定一个大小为 n 的整数序列，选择 m 个位置的数字（其中 m 由读者自定），序列将被分割成$m + 1$个区间，对这 m 个位置的数字求和，又对$m + 1$个区间分别求和（如果区间为空，则和为 0 ），求这$m + 2$个和的最大值的最小可能值。


**题解：**

分析问题，首先从简单情况入手。如果不需要考虑「对 m 个位置的数字求和」，那么直接进行简单的二分然后贪心即可。

如果加上「对 m 个位置的数字求和」呢？由于我们需要求的是最小值，所以问题的单调性依然没有改变，我们依然可以通过二分去得到答案，只是我们二分时判断当前备选值可行性的函数（即代码中的`check()`）需要发生变化。

这样一来，问题转化为：给定一个值 x ， 是否存在一种划分区间的方法，使得「每个区间和」与「选取的数字的和」均小于 x 。可以注意到这个问题是“滑动窗口”问题的一个变体。定义$dp[i]$为“第 i 个位置被选为间隔时，选取的数字的总和的最小值”。转移状态的时候，需要保证两个间隔所夹的区间和小于 x 。最后判断的时候，只要找到一个位置 i 满足$dp[i] < x$即可。同时注意不要忘记最后一个被划分的区间的和也要小于 x 。

# E. 


**题目大意：**

交互题。给定一个大小为 n 的排列 A ，需要通过至多 $40n$ 次询问来确定每个位置上的元素是什么，其中 n 满足 $n <= 2000$。

题目中还有一个位置变量 x ，每次的询问的格式形如“? i”，其中 i 是一个小于 n 的整数。每次询问时，会将 $A[i]$ 与 x 进行比较: 
+ 如果满足 $A[i] > x$，则输出'>'，并进行 $x := x + 1$。
+ 如果满足 $A[i] < x$，则输出'<'，并进行 $x := x - 1$。
+ 如果满足 $A[i] = x$，则输出'='.

**题解：**

注意 n 的取值范围，由于 $\log _2 2000 = 11$， 与 $40$ 为同一数量级，容易想到每个位置的数字是由二分确定的。二分在实践可以分为两种实现思路，一是选择一系列基准值，然后对每个位置上的数字进行二分查询；二是借用快速排序的思想，选定一个基准值后，将序列划分为大于基准值、小于基准值的两个子序列，然后递归下去，直至得到每个位置上的数字。

显然，第二种二分的思路操作上更加简洁可行。

# F. 

**题目大意：**

给定一颗大小为 n 的树，有一个物体从树的根开始移动，有两种移动方式：
+ 移动到一个树上的相邻节点，花费为 1
+ 从当前节点传送到根节点，无花费。但是这种操作仅能进行 k 次

问如果需要遍历树上的所有节点，所需的最小花费是多少。

**题解：**

通过简单的贪心可知，我们只有在到达根节点的时候才使用「传送」。除非使用传送，否则我们只有在遍历完一个子树的所有节点后才移动出该子树。

可以将产生花费的移动分为两类，即「遍历新节点」和「回溯」。每个节点都必须被遍历，所以第一类操作必然花费 $n - 1$。

「回溯」指向着祖先节点的方向移动。为了「回溯」的花费更少，肯定要将「传送」的机会用在“刀刃”上，即在尽可能深的位置上「传送」才到根节点。依照这种思路，对于每个子树，我们将其最深的叶子的回溯路径作为这个离开这个子树时的路径，保证尽可能使得长的路更长，短的路更短，这样使用「传送」才是“最赚的”。

相比于出题人的标程的写法，感觉我代码要简答很多。


# G.

**题目大意：**

给定一个整数 n ，需要构造一个整数序列，这个序列满足：假设原序列为 ${a[1], a[2], ..., a[n]}$，新序列 ${a[2], a[1] + a[3], a[2] + a[4], ..., a[i - 1] + a[i + 1], ..., a[n - 2] + a[n], a[n - 1]}$，则新序列为原序列的一个排列。

要求每个元素均不能为 0 ，但是可以为负数。

**题解：**

遇到这种题目直接打表。先限定每个元素的范围为 $[-5, 5]$ ，找出 n 为 1...8 的所有可能序列，发现 ${-4, -3, 3, -1, 1, 4}$ 多次在不同地方重复地部分或全部出现。研究发现这一段数字每依次增加两个都会使得新序列依然满足条件。据此，我们可以分奇偶考虑，找到不同情况下“基准序列”，然后再扩展之。

我们可以找到 $n = 2$ 和 $n = 7$ 中末尾两位以 $[-4, -3], [3, -1], [1, 4]$ 这三种数组组合结尾的序列，以此为基础。如果有更大的 n ，对 n 按照奇偶进行讨论，然后从这两种基础序列扩展出来即可。


