# 本场摘要

毕业前抱着玩玩的心态打了若干场正式赛，没有训练也没有补题，结果分掉得很严重，都一路俯冲到蓝名去了。。。

后面就没太敢报正式赛了，倒是陪老同学 vp 几场找了找手感。

这一场的Div2是今年的第一场正式赛，最后的 rank 为 第 172 名，rating 从 1733 涨到了 1873，比赛时通过了 ABCDE 五个题目。

下来补完 F 后，综合来看，这场感觉算是中等偏下的难度，也没有让人眼前一亮的题目。期待后续遇到这种偏简单的场次能 AK 一回吧。

**传送门：**

！！！ 待更新

[题目](https://codeforces.com/contest/1946)

[博客中的题解（推荐）]()

# C. 

**题目大意：**

给定一颗大小为 n 的树，去除其中刚好 k 条边，要使得每个联通块的大小都要至少为 x 个点，求 x 的最大值是多少。

**题解：**

十分典的一个贪心题目，先二分 x 的值，然后进行深度优先搜索。一旦当前的子树大小大于了 x，则切掉这个子树与其父亲相连的边，并更新其父节点的大小。如果最后能切掉大约等于 k 条边，则说明当前 x 是可行的。

这个策略可以用反证法证明其正确性。如果遇到这个子树大小大于 x 不切，并且存在另一种合乎要求的切法的话，我们可以在这个新切法的基础上，切掉当前子树与其父相连的边，会得到一个新的小联通块，然后把这个小联通块附着在其他已有的大于 x 的联通块上。

# D. 

**题目大意：**

将一个大小为 n 的正整数序列划分成若干段，设为 k。给定 x，求满足如下式子的 k 的最大值：
$$
\left(a_{l_1} \oplus a_{l_1+1} \oplus \ldots \oplus a_{r_1}\right)\left|\left(a_{l_2} \oplus a_{l_2+1} \oplus \ldots \oplus a_{r_2}\right)\right| \ldots \mid\left(a_{l_k} \oplus a_{l_k+1} \oplus \ldots \oplus a_{r_k}\right) \leq x
$$

**题解：**

这道题给人的第一感觉就是非常的诡异，求解的模型非常陌生，让人一时之间很摸不着头脑。其实 CodeForces 网站上还挺多这种调调的题目的，虽然模型陌生，但是难度倒并不一定很高，比赛的时候需要集中精力，分析问题的切入点。

把 x 按照位拆分，如果自己需要小于 x，只需要在某一位中，x 为 1， 且自己为 0 即可（当然，这里需要保证高位与 x 相同，低位随意）。这样一来，问题就变成了，对于给定的数字 y（这样的 y 有 30 种），如何尽可能多得划分子段，且满足式子最终结果 y' 满足 $y' | y = y$。

求解这个问题，同样需要贪心的策略。假如目前的子段 i 的异或和已经满足 $y^{'}_i = y$, 那么这个子段 i 就可以单独成段：

> 首先。假设 $i = 1$，则不存在一种分段方法，能在当前位置之前进行分段。如果不在这里分段，而是在后面分段，显然最终能在这里分一个新段，且原来的第一段依然满足 $y^{'}_i = y$。所以第一段一定会在满足 $y^{'}_1 = y$ 处进行分割。接下来，去除第一段，问题又成了新的子问题，以此类推，划分方式依然不变。

# E. 

**题目大意：**

给定长度为 n 的一个排列 a。基于这个排列，题目会给出两个序列：
+ 序列一中的每个元素 $p_i$ 满足，如果对于任意 $j < p_i$，则 $a_j > a_{p_i}$
+ 序列一中的每个元素 $s_i$ 满足，如果对于任意 $j > s_i$，则 $a_j < a_{s_i}$
这两个序列的元素都是按照单调递增的顺序给出的。

求满足这两个序列所描述的情况的所有的排列 a 的数量。

**题解：**

很简单的计数题，难度应该是小于 D 题的，不太理解出题人题目放置顺序的考量是怎样的。。。

显然，序列一的最后一个元素和序列二的第一个元素是相等的。设这个元素的值是 x，则 $a_x = n$。否则一定无解。在比较大小时，我们只在意元素间的大小关系，而不在乎具体的值，所以直接随意选出 $x - 1$ 个元素放在左边，$n - x$ 个元素放在右边即可。

左右两边的策略是对称的，所以仅讨论其中一侧的放法即可，这里以左侧为例。

序列一中倒数第二个元素（设为y）一定是左侧这 $x - 1$ 个元素中最大的，然后这个数字将左侧分成了两个部分。第二个部分夹在 y 与 x 中间，总共 $y - x - 1$ 个数字，从$x - 2$ 个数字中随机选取即可。这样问题变成了仅考虑第一部分的新的子问题。这样不停地继续做下去即可。

# F. 

**题目大意：**

给定一个大小为 n 的排列，然后给出 q 个询问，每个询问输入两个值，分别是 l 与 r。求出满足如下要求的子序列数量：
+ 子序列中的元素的下标均在 $[l, r]$ 内。
+ 子序列中相邻元素中，后一个是前一个的整数倍。

**题解：**

估算一次查询的结果大小，以某个元素为起点，则最长的序列长度为 $\log{n}$，则答案最大为 $n * \log{n} * \log{n}$。果能确定序列的第一个元素，则很容易求以这个元素为起点的所有序列的数量，使用一个复杂度为 $n * \log{n} * \log{n}$ 简单 DP 即可（详见代码）。

对于一个查询 $[l, r]$，本质上就是对所有起点在 l 之后，且终点在 r 之前的序列进行求和。我们记录下每一次查询，按照左端点从大到小排列所有询问，然后离线进行求解。我们把从 n 到 1 的每个元素依次作为左端点，计算以此为起点的序列的所有可能终点对应的方案数量，然后使用树状数组加速求和过程。




